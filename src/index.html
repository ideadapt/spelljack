<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="./index.css" rel="stylesheet">
        
        <script type="module">
            import config from '/config.js'
            import {Octokit} from 'octokit'
            import {mergeFindings} from './spelljack.mjs'
            import Alpine from 'alpinejs'    
            window.Alpine = Alpine;

            const octokit = new Octokit({ auth: config.gh_gist_token })

            const sitemapUrl = 'https://www.digitale-gesellschaft.ch/sitemaps/post-sitemap1.xml'
            const urlToTitle = url => url
                .replace(/https:\/\/www.(digitale-gesellschaft|societe-numerique).ch\/\d\d\d\d\/\d\d\/\d\d\//, '')
                .replace(/\/$/, '')
                .replaceAll('-', ' ')
        
            async function articleUrls(sitemapUrl){
                const sitemapRes = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(sitemapUrl)}&rand=${Math.random()}`)
                if(sitemapRes.ok){
                    const xml = JSON.parse(await sitemapRes.text()).contents
                    const parser = new DOMParser()
                    const xmlDoc = parser.parseFromString(xml, "text/xml")
                    return [...xmlDoc.querySelectorAll("loc")].map(el => el.textContent).slice(1)
                }else{
                    throw sitemapRes
                }
            }

            async function extractArticleData(articleUrl){
                const articleRes = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(articleUrl)}&rand=${Math.random()}`)
                if(articleRes.ok){
                    const xml = JSON.parse(await articleRes.text()).contents
                    const parser = new DOMParser()
                    const xmlDoc = parser.parseFromString(xml, "text/html")
                    return {
                        title: xmlDoc.querySelector(".main .entry-title").innerText,
                        html: xmlDoc.querySelector(".main .entry-content").innerHTML,
                        date: xmlDoc.querySelector(".main .entry-meta time").getAttribute('datetime'),
                        id: xmlDoc.querySelector('link[rel=shortlink]').getAttribute('href').match(/p=(\d+)/)[1] || 'no-id',
                    }
                }else{
                    throw articleRes
                }
            }

            function enhanceArticleWithData(article, articleData){
                article.editUrl = `https://www.digitale-gesellschaft.ch/wp-admin/post.php?post=${articleData.id}&action=edit`
            }

            function decodeHTMLEntities(text) {
                const textArea = document.createElement('textarea');
                textArea.innerHTML = text;
                return textArea.value;
            }

            function normalizeContent(articleContent){
                const noHtml = articleContent.replaceAll(/<[^>]*>/g, " ")
                const noNewLines = noHtml.split(/\n/g).join(' ')
                const noColon = noNewLines.replaceAll(':', '')
                return decodeHTMLEntities(noColon)
            }

            async function checkSpelling(text){
                const key = config.key
                const url = `https://api.textgears.com/spelling`
                const spellRes = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'content-type': 'application/json'
                    },
                    body: JSON.stringify({
                        language: "de-CH",
                        dictionary_id: config.dict_name,
                        key,
                        text
                    })
                })
                if(spellRes.ok){
                    const json = await spellRes.json()
                    return [...new Map(json.response.errors.map(error => [error.bad, error])).values()]
                }else{
                    throw spellRes
                }
            }

            async function createDictionary(name){
                const response = await fetch(`https://api.textgears.com/custom/createdictionary?key=${config.key}&id=${config.dict_name}&title=${config.dict_title}`,
                    {
                        method: 'POST'
                    }
                )
                if(!response.ok){
                    throw response
                }
            }

            async function ignoreFinding(finding){
                const response = await fetch(`https://api.textgears.com/custom/addexception?key=${config.key}&dictionary_id=${config.dict_name}&type=2&lang=de-CH&text=${finding.word}`, 
                {
                    method: 'POST'
                })
                if(response.ok){
                    finding.exceptionId = (await response.json()).response.id
                    finding.ignore = true
                } else {
                    throw response
                }
                
            }
            async function unIgnoreFinding(finding){
                const response = await fetch(`https://api.textgears.com/custom/deleteexception?key=${config.key}&id=${finding.exceptionId}`, 
                {
                    method: 'POST'
                })
                if(response.ok){
                    finding.exceptionId = null
                    finding.ignore = false
                } else {
                    throw response
                }
            }
            //const errors = await checkSpelling(normalizedContent)
            /** error is: 
                bad: "EDRi-Netzwerk"
                better: Array(5) [ "DDR-Netzwerk", "Der-Netzwerk", "NDR-Netzwerk", … ]
                description: Object { en: "Möglicher Tippfehler gefunden." }
                id: "e33121016"
                length: 13
                offset: 5
                type: "spelling" 
                */


            function mapToFindings(errors, url){
                return errors.map(e => {
                    return {
                        word: e.bad,
                        ignore: false,
                        selected: false,
                        refs: [url]
                    }
                })
            }

            async function loadState(){
                const gist = await octokit.request(`GET /gists/${config.gist_id}`, {
                    gist_id: config.gist_id
                })
                const gistText = gist.data.files['db.json'].content
                const gistJson = JSON.parse(gistText)
                if(!("findings" in gistJson)){
                    gistJson.findings = []
                }
                return gistJson
            }
            async function storeState(state){
                await octokit.request(`PATCH /gists/${config.gist_id}`, {
                    gist_id: config.gist_id,
                    description: 'spelljack-db-' + config.dict_name,
                    files: {
                        'db.json': { content: JSON.stringify(state) }
                    }
                })
            }

            async function storeFindings(findings){
                const state = await loadState()
                state.findings = findings.map(f => ({...f, selected: false}))
                await storeState(state)
            }

            async function loadFindings(){
                return (await loadState()).findings
            }

            // TODO 
            // - show last scan date for each article
            // - show context of word (e.g. surrounding 5 words)

            window.spelljackApp = function(){
                return {
                    articles: [],
                    findings: [],
                    scanning: false,
                    articlesLoading: true,
                    findingsLoading: true,
                    showIgnored: false,
                    filterFindingsBySelectedArticles: false,
                    filterArticlesBySelectedFindings: false,
                    async init(){
                        console.log('init')

                        await Promise.all([
                            articleUrls(sitemapUrl).then(urls => {
                                this.articles = urls.map(url => {
                                    return {
                                        url,
                                        editUrl: '',
                                        title: urlToTitle(url),
                                        checks: [],
                                        selected: false
                                    }
                                })
                                this.articlesLoading = false
                            }),
                            loadFindings().then(fs => {
                                this.findings = fs
                                this.findingsLoading = false
                            }),
                            createDictionary()
                        ])
                    },
                    async scan(url){
                        this.scanning = true
                        console.log('scanning', url)
                        const articleData = await extractArticleData(url)
                        enhanceArticleWithData(this.articles.filter(a => a.url === url)[0], articleData)
                        const errors = await checkSpelling(normalizeContent(articleData.html))
                        const findings = mapToFindings(errors, url)
                        console.log('findings', findings)
                        this.scanning = false
                        return findings
                    },
                    async scanSelected(){
                        this.articles.filter(a => a.selected).forEach(async a => {
                            const findings = await this.scan(a.url)
                            a.checks.push({ date: new Date()}) // TODO articles not stored yet, check date has no value yet
                            this.findings = mergeFindings(findings, this.findings)
                        })
                        storeFindings(this.findings)
                    },
                    async toggleIgnoreSelected(){
                        this.findings.filter(f => f.selected).forEach(async f => {
                            if(f.ignore){
                                await unIgnoreFinding(f)
                            }else{
                                await ignoreFinding(f)
                            }
                            f.selected = false
                            storeFindings(this.findings)
                        })
                    },
                    get nrOfSelectedArticles(){
                        return this.articles.filter(a => a.selected).length
                    },
                    get nrOfSelectedFindings(){
                        return this.findings.filter(f => f.selected).length
                    },
                    get filteredFindings(){
                        const selectedArticleUrls = this.articles.filter(a => a.selected).map(a => a.url)

                        return this.findings.filter(f => 
                            (this.showIgnored || !f.ignore) &&
                            ((this.filterFindingsBySelectedArticles && (selectedArticleUrls.length === 0 || 
                                f.refs.some(r => selectedArticleUrls.includes(r))
                            ))
                            || !this.filterFindingsBySelectedArticles)
                        )
                        .sort((a, b) => b.ignore - a.ignore || a.word.localeCompare(b.word))
                    },
                    get filteredArticles(){
                        const selectedFindings = this.findings.filter(f => f.selected)
                        return this.articles.filter(a => 
                            ((this.filterArticlesBySelectedFindings && (selectedFindings.length === 0 || 
                                selectedFindings.some(f => f.refs.some(urlToSelect => a.url === urlToSelect))
                            ))
                            || !this.filterArticlesBySelectedFindings)
                        )
                    },
                    
                }
            }
            window.addEventListener('DOMContentLoaded', ()=>{
                document.querySelectorAll('[x-component]').forEach(component => {
                    const componentName = `x-${component.getAttribute('x-component')}`
                    class Component extends HTMLElement {
                        connectedCallback() {
                            this.append(component.content.cloneNode(true))
                        }
            
                        data() {
                            const attributes = this.getAttributeNames()
                            const data = {}
                            attributes.forEach(attribute => {
                                data[attribute] = this.getAttribute(attribute)
                            })
                            return data
                        }
                    }
                    customElements.define(componentName, Component)
                })
            })
        </script>
        <template x-component="toggle-button">
            <div x-data="{ ...$el.parentElement.data(), id: Math.floor(Math.random()*10000) }">
                <label :for="`${id}`" class="inline-flex relative items-center cursor-pointer">
                    <input type="checkbox" :id="`${id}`" x-on:change="$el.parentElement.parentElement.parentElement._x_model.set($el.checked)" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-amber-600"></div>
                    <span class="ml-2 whitespace-nowrap text-sm font-medium text-gray-900" x-text="`${text}`"></span>
                </label>
            </div>
        </template>
    </head> 
    <body x-data="spelljackApp()" class="font-sans m-5 container mx-auto text-gray-800 bg-amber-50">
        <div class="flex flex-row gap-10">
            <article class="basis-2/3">
                <h1 class="text-xl">Articles</h1>
                <div class="py-3 pb-8 flex gap-4 items-center">
                    <button x-on:click.prevent="scanSelected()" :class="{'!bg-slate-400 !cursor-not-allowed': nrOfSelectedArticles == 0}">
                        Check spelling
                        <svg x-show="scanning" class="stroke-amber-200 inline ml-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin:auto;background:transparent;display:block;" width="20px" height="20px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
                            <path fill="none" stroke-width="8" stroke-dasharray="42.76482137044271 42.76482137044271" d="M24.3 30C11.4 30 5 43.3 5 50s6.4 20 19.3 20c19.3 0 32.1-40 51.4-40 C88.6 30 95 43.3 95 50s-6.4 20-19.3 20C56.4 70 43.6 30 24.3 30z" stroke-linecap="round" style="transform:scale(0.8);transform-origin:50px 50px">
                              <animate attributeName="stroke-dashoffset" repeatCount="indefinite" dur="7.142857142857142s" keyTimes="0;1" values="0;256.58892822265625"></animate>
                            </path>
                        </svg>
                        
                    </button>
                    <x-toggle-button text="Filter finding" x-model="filterFindingsBySelectedArticles"></x-toggle-button>
                </div>
                <div class="overflow-y-scroll shadow-md" style="height: calc(100vh - 9rem)">
                    <svg x-show="articlesLoading" class="stroke-amber-700" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin:auto;background:transparent;display:block;" width="100px" height="100px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
                        <path fill="none" stroke-width="8" stroke-dasharray="42.76482137044271 42.76482137044271" d="M24.3 30C11.4 30 5 43.3 5 50s6.4 20 19.3 20c19.3 0 32.1-40 51.4-40 C88.6 30 95 43.3 95 50s-6.4 20-19.3 20C56.4 70 43.6 30 24.3 30z" stroke-linecap="round" style="transform:scale(0.8);transform-origin:50px 50px">
                          <animate attributeName="stroke-dashoffset" repeatCount="indefinite" dur="7.142857142857142s" keyTimes="0;1" values="0;256.58892822265625"></animate>
                        </path>
                    </svg>
                    <table class="w-full">
                        <template x-for="article in filteredArticles" :key="article.url">
                            <tr class="odd:bg-slate-50 even:bg-white select-none hover:cursor-pointer hover:bg-slate-100" 
                                :class="{ '!bg-amber-200': article.selected }"
                                x-on:click="article.selected = !article.selected">
                                <td x-text="`${article.title}`"
                                    class="px-3 py-3 max-w-prose truncate"></td>
                                <td class="p-3"><a :href="article.editUrl" target="_blank" class="hover:stroke-amber-700 stroke-slate-500">
                                    <svg xmlns="http://www.w3.org/2000/svg" style="transform: scale(0.75)" width="20" height="20"><path fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 11v6a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M13 1h6v6M8 12 19 1"/></svg>
                                </a></td>
                            </tr>
                        </template>
                    </table>
                </div>
            </article>
            <article class="basis-1/3">
                <h1 class="text-xl">Findings</h1>
                <div class="py-3 pb-8 flex flex-row gap-4 justify-between items-center">
                    <button x-on:click.prevent="toggleIgnoreSelected()" :class="{'!bg-slate-400 !cursor-not-allowed': nrOfSelectedFindings === 0}">Toggle ignore</button>
                    <x-toggle-button text="Show ignored" x-model="showIgnored"></x-toggle-button>
                    <x-toggle-button text="Filter articles" x-model="filterArticlesBySelectedFindings"></x-toggle-button>
                </div>
                <div class="overflow-y-scroll shadow-md w-full" style="height: calc(100vh - 9rem)">
                    <svg x-show="findingsLoading" class="stroke-amber-700" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin:auto;background:transparent;display:block;" width="100px" height="100px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
                        <path fill="none" stroke-width="8" stroke-dasharray="42.76482137044271 42.76482137044271" d="M24.3 30C11.4 30 5 43.3 5 50s6.4 20 19.3 20c19.3 0 32.1-40 51.4-40 C88.6 30 95 43.3 95 50s-6.4 20-19.3 20C56.4 70 43.6 30 24.3 30z" stroke-linecap="round" style="transform:scale(0.8);transform-origin:50px 50px">
                          <animate attributeName="stroke-dashoffset" repeatCount="indefinite" dur="7.142857142857142s" keyTimes="0;1" values="0;256.58892822265625"></animate>
                        </path>
                    </svg>
                    <p x-show="filteredFindings.length === 0 && !findingsLoading" class="text-center p-3">No findings! Maybe spell check another article?</p>
                    <table class="w-full">
                        <tbody>
                            <template x-for="finding in filteredFindings" :key="finding.word">
                                <tr class="odd:bg-slate-50 even:bg-white hover:cursor-pointer hover:bg-slate-100" 
                                    :class="{ '!bg-amber-200': finding.selected }"
                                    x-on:click="finding.selected = !finding.selected">
                                    <td x-text="`${finding.word}`" class="px-3 py-1.5 w-full"></td>
                                    <td class="px-3 py-1.5">
                                        <svg x-show="!finding.ignore" xmlns="http://www.w3.org/2000/svg" class="stroke-amber-500 fill-amber-500" viewBox="0 0 256 256" width="20" height="20"><rect width="256" height="256" fill="none"/><circle cx="128" cy="128" r="96" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="180" r="12"/><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="16" d="M127.9995,144.0045v-8a28,28,0,1,0-28-28"/></svg>
                                        <svg x-show="finding.ignore" xmlns="http://www.w3.org/2000/svg" class="fill-green-500" viewBox="0 0 64 64" width="16" height="16"><path d="M20.27,52.78a3,3,0,0,0,4.24,0L61.1,16.19A3,3,0,0,0,56.86,12L22.39,46.42,7,31.07A3,3,0,1,0,2.8,35.31Z"/></svg>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </article>
        </div>
        <footer class="text-sm text-gray-500 mt-10">
            <p>
                SVG icons from <a href="https://iconscout.com">IconScout</a> by <a href="https://iconscout.com/contributors/feathericons">Feather Icons</a>, <a href="https://iconscout.com/contributors/eva-icons">Akveo</a>, <a href="https://iconscout.com/contributors/andinur">Andi Nur Abdillah</a>
            </p>
            <p>
                SVG icons from <a href="https://loading.io/license/#free-license">loading.io</a>
            </p>
            <p>
                Code at <a href="https://github.com/ideadapt/spelljack">ideadapts spelljack repo</a>
            </p>
        </footer>
        <script defer>   
            Alpine.start()
        </script>
    </body>
</html>