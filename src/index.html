<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="./index.css" rel="stylesheet">
        <script type="module">
            import config from '/config.js'
            window.spelljack = config
        </script>
        <script>
            const sitemapUrl = 'https://www.digitale-gesellschaft.ch/sitemaps/post-sitemap1.xml'
            const urlToTitle = url => url
                .replace(/https:\/\/www.(digitale-gesellschaft|societe-numerique).ch\/\d\d\d\d\/\d\d\/\d\d\//, '')
                .replace(/\/$/, '')
        
            async function articleUrls(sitemapUrl){
                const sitemapRes = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(sitemapUrl)}&rand=${Math.random()}`)
                if(sitemapRes.ok){
                    const xml = JSON.parse(await sitemapRes.text()).contents
                    const parser = new DOMParser()
                    const xmlDoc = parser.parseFromString(xml, "text/xml")
                    return [...xmlDoc.querySelectorAll("loc")].map(el => el.textContent).slice(1)
                }else{
                    throw sitemapRes
                }
            }

            async function extractArticleContent(articleUrl){
                const articleRes = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(articleUrl)}&rand=${Math.random()}`)
                if(articleRes.ok){
                    const xml = JSON.parse(await articleRes.text()).contents
                    const parser = new DOMParser()
                    const xmlDoc = parser.parseFromString(xml, "text/html")
                    return {
                        title: xmlDoc.querySelector(".main .entry-title").innerText,
                        html: xmlDoc.querySelector(".main .entry-content").innerHTML,
                        date: xmlDoc.querySelector(".main .entry-meta time").getAttribute('datetime')
                    }
                }else{
                    throw articleRes
                }
            }

            function decodeHTMLEntities(text) {
                const textArea = document.createElement('textarea');
                textArea.innerHTML = text;
                return textArea.value;
            }

            function normalizeContent(articleContent){
                const noHtml = articleContent.replaceAll(/<[^>]*>/g, " ")
                const noNewLines = noHtml.split(/\n/g).join(' ')
                return decodeHTMLEntities(noNewLines)
            }

            async function checkSpelling(text){
                const key = window.spelljack.key
                const url = `https://api.textgears.com/spelling`
                const spellRes = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'content-type': 'application/json'
                    },
                    body: JSON.stringify({
                        language: "de-CH",
                        key,
                        text
                    })
                })
                if(spellRes.ok){
                    const json = await spellRes.json()
                    return [...new Map(json.response.errors.map(error => [error.bad, error])).values()]
                }else{
                    throw spellRes
                }
            }

            async function createDictionary(name){
                const response = await fetch(`https://api.textgears.com/custom/createdictionary?key=${window.spelljack.key}&id=${window.spelljack.dict_key}&title=${window.spelljack.dict_title}`,
                    {
                        method: 'POST'
                    }
                )
                if(!response.ok){
                    throw response
                }
            }

            async function ignoreFinding(finding){
                const response = await fetch(`https://api.textgears.com/custom/addexception?key=${window.spelljack.key}&dictionary_id=${window.spelljack.dict_key}&type=2&lang=de-CH&text=${finding.word}`, 
                {
                    method: 'POST'
                })
                if(response.ok){
                    finding.exceptionId = (await response.json()).response.id
                    finding.ignore = true
                } else {
                    throw response
                }
                
            }
            async function unIgnoreFinding(finding){
                const response = await fetch(`https://api.textgears.com/custom/deleteexception?key=${window.spelljack.key}&id=${finding.exceptionId}`, 
                {
                    method: 'POST'
                })
                if(response.ok){
                    finding.exceptionId = null
                    finding.ignore = false
                } else {
                    throw response
                }
            }
            //const errors = await checkSpelling(normalizedContent)
            /** error is: 
                bad: "EDRi-Netzwerk"
                better: Array(5) [ "DDR-Netzwerk", "Der-Netzwerk", "NDR-Netzwerk", … ]
                description: Object { en: "Möglicher Tippfehler gefunden." }
                id: "e33121016"
                length: 13
                offset: 5
                type: "spelling" 
                */


            function mapToFindings(errors, url){
                return errors.map(e => {
                    return {
                        word: e.bad,
                        ignore: false,
                        selected: false,
                        refs: [url]
                    }
                })
            }

            const storeName = 'spellcheck'
            function loadState(){
                const state = localStorage.getItem(storeName)
                if(!state){
                    const newState = {
                        findings: []
                    }
                    localStorage.setItem(storeName, JSON.stringify(newState))
                    return newState
                }
                return JSON.parse(state)
            }
            function storeState(state){
                localStorage.setItem(storeName, JSON.stringify(state))
            }

            function storeFindings(findings){
                const state = loadState()
                state.findings = findings.map(f => ({...f, selected: false}))
                storeState(state)
            }

            function loadFindings(){
                return loadState().findings
            }

            /**
             * add finding-url to existing finding if same word
             * remove all existing finding refs not present in findings
            */
            function mergeFindings(findings, existingFindings){
                const newFindings = new Set(findings)
                for(const newFinding of newFindings){
                    const scannedRef = newFinding.refs[0]

                    const existing = existingFindings.find(ef => ef.word === newFinding.word)
                    if(existing){
                        // TODO use Set
                        existing.refs.push(scannedRef)
                        existing.refs = [...new Set(existing.refs)]
                        newFindings.delete(newFinding)
                    }
                }

                existingFindings = existingFindings.filter(ef => 
                    ef.refs.some(r => 
                        findings.some(f => ef.word === f.word && f.refs[0] === r))
                )
                        
                existingFindings.push(...(newFindings.values()))
                existingFindings.sort((a, b) => a.word.localeCompare(b.word))
                return existingFindings
            }

            // TODO 
            // - show last scan date for each article

            function state(){
                return {
                    articles: [],
                    findings: [],
                    showIgnored: false,
                    filterFindingsBySelectedArticles: false,
                    filterArticlesBySelectedFindings: false,
                    async init(){
                        console.log('init')
                        const urls = await articleUrls(sitemapUrl)
                        this.articles = urls.map(url => {
                            return {
                                url,
                                title: urlToTitle(url),
                                checks: [],
                                selected: false
                            }
                        })
                        this.findings = loadFindings()
                        createDictionary()
                    },
                    async scan(url){
                        console.log('scanning', url)
                        const content = await extractArticleContent(url)
                        const errors = await checkSpelling(normalizeContent(content.html))
                        const findings = mapToFindings(errors, url)
                        console.log('findings', findings)
                        
                        return findings
                    },
                    async scanSelected(){
                        this.articles.filter(a => a.selected).forEach(async a => {
                            const findings = await this.scan(a.url)
                            a.checks.push({ date: new Date()}) // TODO articles not stored yet, check date has no value yet
                            this.findings = mergeFindings(findings, this.findings)
                        })
                        storeFindings(this.findings)
                    },
                    async toggleIgnoreSelected(){
                        this.findings.filter(f => f.selected).forEach(async f => {
                            if(f.ignore){
                                await unIgnoreFinding(f)
                            }else{
                                await ignoreFinding(f)
                            }
                            f.selected = false
                            storeFindings(this.findings)
                        })
                    },
                    get nrOfSelectedArticles(){
                        return this.articles.filter(a => a.selected).length
                    },
                    get nrOfSelectedFindings(){
                        return this.findings.filter(f => f.selected).length
                    },
                    get filteredFindings(){
                        const selectedArticleUrls = this.articles.filter(a => a.selected).map(a => a.url)

                        return this.findings.filter(f => 
                            (this.showIgnored || !f.ignore) &&
                            ((this.filterFindingsBySelectedArticles && (selectedArticleUrls.length === 0 || 
                                f.refs.some(r => selectedArticleUrls.includes(r))
                            ))
                            || !this.filterFindingsBySelectedArticles)
                        )
                    },
                    get filteredArticles(){
                        const selectedFindings = this.findings.filter(f => f.selected)
                        return this.articles.filter(a => 
                            ((this.filterArticlesBySelectedFindings && (selectedFindings.length === 0 || 
                                selectedFindings.some(f => f.refs.some(urlToSelect => a.url === urlToSelect))
                            ))
                            || !this.filterArticlesBySelectedFindings)
                        )
                    },
                    
                }
            }
            window.addEventListener('DOMContentLoaded', ()=>{
                document.querySelectorAll('[x-component]').forEach(component => {
                    const componentName = `x-${component.getAttribute('x-component')}`
                    class Component extends HTMLElement {
                        connectedCallback() {
                            this.append(component.content.cloneNode(true))
                        }
            
                        data() {
                            const attributes = this.getAttributeNames()
                            const data = {}
                            attributes.forEach(attribute => {
                                data[attribute] = this.getAttribute(attribute)
                            })
                            return data
                        }
                    }
                    customElements.define(componentName, Component)
                })
            })
        </script>
        <script defer src="../node_modules/alpinejs/dist/cdn.js"></script>
        <template x-component="toggle-button">
            <div x-data="{ ...$el.parentElement.data(), id: Math.floor(Math.random()*10000) }">
                <label :for="`${id}`" class="inline-flex relative items-center cursor-pointer">
                    <input type="checkbox" :id="`${id}`" x-on:change="$el.parentElement.parentElement.parentElement._x_model.set($el.checked)" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-amber-600"></div>
                    <span class="ml-2 whitespace-nowrap text-sm font-medium text-gray-900" x-text="`${text}`"></span>
                </label>
            </div>
        </template>
    </head> 
    <body x-data="state()" class="font-sans m-5 container mx-auto text-gray-800 bg-amber-50">
        <div class="flex flex-row gap-10">
            <article class="basis-2/3">
                <h1 class="text-xl">Articles</h1>
                <div class="py-3 pb-8 flex gap-4 items-center">
                    <button x-on:click.prevent="scanSelected()" :class="{'!bg-slate-400 !cursor-not-allowed': nrOfSelectedArticles == 0}">Scan</button>

                    <x-toggle-button text="Filter finding" x-model="filterFindingsBySelectedArticles"></x-toggle-button>
                </div>
                <div class="overflow-y-scroll shadow-md" style="height: calc(100vh - 9rem)">
                    <table class="w-full">
                        <template x-for="article in filteredArticles">
                            <tr class="odd:bg-slate-50 even:bg-white select-none hover:cursor-pointer hover:bg-slate-100" 
                                :class="{ '!bg-amber-200': article.selected }"
                                x-on:click="article.selected = !article.selected">
                                <td x-text="`${article.title}`" class="px-3 py-1.5 max-w-prose truncate"></td>
                                <td class="p-2"><a :href="article.url" target="_blank" class="hover:stroke-amber-700 stroke-slate-500">
                                    <svg xmlns="http://www.w3.org/2000/svg" style="transform: scale(0.75)" width="20" height="20"><path fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 11v6a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M13 1h6v6M8 12 19 1"/></svg>
                                </a></td>
                            </tr>
                        </template>
                    </table>
                </div>
            </article>
            <article class="basis-1/3">
                <h1 class="text-xl">Findings</h1>
                <div class="py-3 pb-8 flex flex-row gap-4 justify-between items-center">
                    <button x-on:click.prevent="toggleIgnoreSelected()" :class="{'!bg-slate-400 !cursor-not-allowed': nrOfSelectedFindings === 0}">Toggle ignore</button>
                    
                    <x-toggle-button text="Show ignored" x-model="showIgnored"></x-toggle-button>

                    <x-toggle-button text="Filter articles" x-model="filterArticlesBySelectedFindings"></x-toggle-button>

                </div>
                <table class="max-w-md shadow-md">
                    <tbody>
                        <template x-for="finding in filteredFindings">
                            <tr class="odd:bg-slate-50 even:bg-white hover:cursor-pointer hover:bg-slate-100" 
                                :class="{ '!bg-amber-200': finding.selected }"
                                x-on:click="finding.selected = !finding.selected">
                                <td x-text="`${finding.word}`" class="px-3 py-1.5"></td>
                                <td class="px-3 py-1.5">
                                    <svg x-show="!finding.ignore" xmlns="http://www.w3.org/2000/svg" class="stroke-amber-500 fill-amber-500" viewBox="0 0 256 256" width="20" height="20"><rect width="256" height="256" fill="none"/><circle cx="128" cy="128" r="96" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="180" r="12"/><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="16" d="M127.9995,144.0045v-8a28,28,0,1,0-28-28"/></svg>
                                    <svg x-show="finding.ignore" xmlns="http://www.w3.org/2000/svg" class="fill-green-500" viewBox="0 0 64 64" width="16" height="16"><path d="M20.27,52.78a3,3,0,0,0,4.24,0L61.1,16.19A3,3,0,0,0,56.86,12L22.39,46.42,7,31.07A3,3,0,1,0,2.8,35.31Z"/></svg>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </article>
        </div>
        <footer class="text-sm text-gray-500 mt-10">
            SVG icons from <a href="https://iconscout.com">IconScout</a> by <a href="https://iconscout.com/contributors/feathericons">Feather Icons</a>, <a href="https://iconscout.com/contributors/eva-icons">Akveo</a>, <a href="https://iconscout.com/contributors/andinur">Andi Nur Abdillah</a>
        </footer>
    </body>
</html>